For my portfolio artifact, I built PingPlan, an Android event-tracking app designed to help students, parents, and busy professionals quickly record upcoming events and receive simple day-of reminders. The core requirements I implemented were a local SQLite database with two tables (users and events), a login screen that also creates a first-time account, an events list that shows upcoming items in date order, full CRUD for events, and a mechanism to notify users on the day an event is scheduled. My goal was to provide a fast, offline, privacy-first tool that keeps people focused on what’s coming up today and this week.

To support user needs with a user-centered UI, I kept the flow minimal: a Login/Create Account screen, an Events List, and a dedicated SMS screen. Adding an event is intentionally quick—enter a title, location, and notes, then pick a date and time. The list sorts by the event time so the next commitment is always easy to see, and editing or deleting takes only a tap. I moved all text to strings.xml for clarity and future localization, chose readable copy, and ensured sensible empty states and permission-denied messages. These choices make the app easy to learn, predictable to use, and friendly even when a permission is declined.

My coding approach was story-driven and incremental. I implemented each user story end-to-end, verified it on the emulator, and only then moved on. Technically, I used an SQLiteOpenHelper for persistence with helper methods like getUpcomingEvents() and getTodaysEvents(). The list is built with RecyclerView and an adapter that uses DiffUtil to render only what changed, which keeps the UI smooth. I handled runtime permissions with an ActivityResultLauncher, requested SMS only when the user asks to send a reminder, and set explicit android:exported flags in the manifest for Android 12+. I kept classes small, names consistent, and added comments where intent wasn’t obvious. These patterns are reusable and will carry forward to features like recurring events or calendar export.

Testing was a mix of functional checks and platform validation. I ran the app on multiple emulator images (API 30–34), exercised the full CRUD path, and confirmed data persisted across restarts. I verified the SMS flow in both branches—permission granted (SMS summary of today’s events is sent) and permission denied (the app continues and informs the user). This process mattered because it exposed edge cases early, such as empty-list handling, picker defaults, and permission timing, and it ensured compliance with modern Android requirements. Along the way I found that using DiffUtil eliminated unnecessary redraws and that centralizing UI text in resources improved consistency and removed lint warnings.

From planning to finalization, the biggest shift was refining scope. I migrated from an earlier inventory concept to an event model that better matched the rubric and the target users. That change required a schema update, adapter rewrite, and small UI adjustments, plus careful manifest and permission work for Android 12+. Where I had to innovate was in delivering a rubric-compliant “day-of” notification that remained simple and privacy-friendly. The solution was an optional “today’s events” SMS with a graceful in-app fallback when permission is denied—meeting the requirement without burdening the user.

The component I’m most proud of is the combination of the SQLite helper and the RecyclerView list. The database layer is clear and easy to extend, and the DiffUtil-powered adapter keeps updates efficient and the interface responsive. Together with disciplined permission handling and resource-driven copy, they demonstrate my progress from a code-first mindset to a more deliberate, user-story-driven approach that balances functionality, UX, and platform best practices.
